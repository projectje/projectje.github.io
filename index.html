<html>
    <head>
        <link href="https://fonts.googleapis.com/css?family=Fira+Code|Roboto&display=swap" rel="stylesheet">
        <style>
            h1 {
                font-family: 'Fira Code', monospace;
                font-size: 18px;
                text-shadow: 4px 4px 4px #aaa;
            }
            body {
                font-family: 'Fira Code', monospace;
                font-size: 12px;
            }
        </style>
        <title>Cogmios' (Future) Static Place</title>
    </head>
<body>
<h1>Cogmios' (Future) Static Place</h1>
<pre>
    ░░░░░░░░░░░░░░░░░░░░░░█████████
    ░░███████░░░░░░░░░░███▒▒▒▒▒▒▒▒███
    ░░█▒▒▒▒▒▒█░░░░░░░███▒▒▒▒▒▒▒▒▒▒▒▒▒███
    ░░░█▒▒▒▒▒▒█░░░░██▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██
    ░░░░█▒▒▒▒▒█░░░██▒▒▒▒▒██▒▒▒▒▒▒██▒▒▒▒▒███
    ░░░░░█▒▒▒█░░░█▒▒▒▒▒▒████▒▒▒▒████▒▒▒▒▒▒██
    ░░░█████████████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██
    ░░░█▒▒▒▒▒▒▒▒▒▒▒▒█▒▒▒▒▒▒▒▒▒█▒▒▒▒▒▒▒▒▒▒▒██
    ░██▒▒▒▒▒▒▒▒▒▒▒▒▒█▒▒▒██▒▒▒▒▒▒▒▒▒▒██▒▒▒▒██
    ██▒▒▒███████████▒▒▒▒▒██▒▒▒▒▒▒▒▒██▒▒▒▒▒██
    █▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▒▒▒▒▒▒████████▒▒▒▒▒▒▒██
    ██▒▒▒▒▒▒▒▒▒▒▒▒▒▒█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██
    ░█▒▒▒███████████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██
    ░██▒▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█
    ░░████████████░░░█████████████████
</pre>
<h2></h2>September 2019</h2>
<p>
    Was on my todo list but today added a  page (<a href="https://pages.github.com/"> pages </a></a>)
    Instead of using a tool like <a href="https://jekyllrb.com/">Jekyll</a> I think I will create something in PowerShell that will
    generate my static pages. Undoubtly someone has already made this but its probably only a few hours work (...) to do so.
    I think there will be something like posts. When I started blogging the concept of a headline did not exist, i think I will revert
    to this, since headlines became SEO and is way to pretentious. It will need some taxonomy (tags,categories, projects), a search system,
    a comment system, a way to store media, a way to handle links outdated, special sections for specific topics, etc... so in the end
    it might be more than a few hours work.
</p>
<p>
    Probably there are little pieces of content which have a type e.g. a post, page, bookmarks and so on, each of these have properties
    and the properties can be complex and custom. Each of these pieces of content can have a specific workflow attached, which is code.
    So I think each of these pieces of content is an object based on a class. So probably there needs to be folder class definitions first.
    Classes have their own taxonomy.<br />
    To import tens of thousands of wordpress posting (and before wordpress from the end 90's). Its probably handy to include the properties
    that WordPress exports in its backup XML file, so that a mass conversion is the easiest this will be:
    <ul>
        <li>item
            <ul>
                <li>title</li>
                <li>link</li>
                <li>pubDate</li>
                <li>dc:creator</li>
                <li>guid with indication if permalink</li>
                <li>description</li>
                <li>content:encoded which is a CDATA item</li>
                <ul>
                    <li>this contains relative and fixed paths so a conversion needs to run here</li>
                    <li>it would also be nice if a linkchecker removes any links that are outdated</li>
                    <li>some spellchecker would be very nice...</li>
                </ul>
                <li>expert: idem also encoded Cdata, in my case mostly empty</li>
                <li>wp:post_id might be handy to keep as reference</li>
                <li>wp:post_date might be handy to keep as reference</li>
                <li>wp:post_date_gmt idem</li>
                <li>wp:comment_status idem</li>
                <li>wp:ping_status idem but never used it</li>
                <li>wp:status idem</li>
                <li>wp:post_parent</li>
                <li>wp:menu_order</li>
                <li>wp:post_type</li>
                <li>wp_post_password probably useless in new system</li>
                <li>wp:is_sticky probably handy to convert to equal functionality</li>
                <li>category domain niceame cdata : will convert these but keep the old ones around for reference</li>
                <li>wp:postmeta consisting of wp:meta_key and wp_meta_value (CDATA) will convert these but keep old ones around for reference</li>

            </ul>
        </li>
        I think I have roughly 20.000 individual postings since 99, problem is that I sometimes posted things I dont agree with anymore, and also
        it contains a gazillion links that no longer exists or where there are now different sites. So I might in the end need to check them one by ones
        and add some annotation OR put some annotation above like "not re-reviewed yet disclaimer" or something alike.
        Also since I have multiple backups of different blogs, might need to find a mechanism to filter out duplicate entries, since I did some conversions
        in between, might not be 1:1.
    </ul>
</p>
<p>
    So to do this incremental the simplest way to start is probably to have a sidebar with each individual blog entry. That can later be replaced by
    tags, categories, aggregated blog overviews etc. "Styling" is something that go on endless so dont care about this. What is maybe important is the
    translation or indication if items are in Dutch or in English. Have to think about this but it might be a label OR very pretentious holds a master item
    with links to various translations. that would require a subdir for each post e.g. NL_nl for dutch and only in there the content, title and such while
    other meta properties reside one level higher. But that is too labor intensive.
</p>
<h2>Setup of New System</h2>
<p>
I think... it will be something like this: <br />
I want to stay away from defining types upfront such as "addressbookentry", "blogpost", "bookmarks" and also stay away from upfront defining
a taxonomy of things such as TAG X or category Y.
I wonder if the approach will work to start off with the bottom to top instead of top to bottom: just placing all content
the system finds in individual files (tens of thousands) and let the system classify (or probably a human) it to types and taxonomy.
</p>
<h3>Parsed Data Folder: Value ("Things", "The real stuff", the "yet unstructured data")</h3>
This can contains known things ("typed") and unknown things. If we know the thing e.g. it had a xml key or a json key then it will be placed
in a subfolder with the name of that key. It is then the assumption on that content. Later on we may manually make different choices on
the subfolders through extra rules. Later on this may also involve the content parts themselves e.g. if we find "red" in a blogposting, we
could auto classify it.<br />
Some items will naturally become types (or enumerations) but things found only once or twice are harder.
<p>
    A folder "values" will contains textfiles with a part of the name found along with a guid.
    <ul>
        <li>The filename will be part of the text + a GUID.  I could have used the date-time instead but it would create
            too many duplicates. Since a new thing  can arise on exact the same moment, in a different place. In theory we
            could also name it the first time we encounter it (filename) + datetimestamp. </li>
        <li>It will contain "parents:" , behind it, it will list all things where it found this in. E.g. if an object contains
            "nl_NL" it will add the filename of that object in there. This is for perfomance reasons, to reconstruct the
            original data if all else is lost and maybe for reverse engineering types from text files versus a virtual index
            on the items
        <li>It will contain "value:", where the content is placed e.g. "NL_nl"</li>
    </ul>
</p>
<h3>Classification Folder: Type/Simple (a group of terms in a taxonomy)</h3>
<p>
    When we find a new type in the content / objects we will move all files in things to a new subfolder in things with the name of the type
    (either a GUID or a name).
    We will also create a powershell ps1 file inside the folder types that references the new folder.
    In this powershell file we can define constraint, workflows or other special behavior for this type.
</p>
<h3>Classification Folder: Type/Complex  (a group of groups terms in a yet another taxonomy)</h3>
<p>
    When we find combinations of types being new types. We will create a ps1 file with a GUID under complex types which lists the folders
    of the simple types as a constraint.
    We will have the option to name it and have the option to add special constraints or behaviors for it.
    This will also include a template (or more) for a certain complex type. These templates can be used to quickly create content
    in the Raw Data Folder.
</p>
<h3>Classification Folder: Content (Objects) (which links the values to the types)</h3>
<p>
    This is where store the combination of values in relation to types. E.g. if we find attribute "language" on a "title" inside a "item"
    we store language 3342 to title 4343 to item 45454.
</p>
<h3>Raw Data Folder: Data</h3>
<p>
    Here we raw dump all data. The text files will are stored in various formats. The objects have
    relations to other objects e.g. we could split the wordpress backup file to "blog file" and have all the individual blog items
    as individual text files.
    A (in time smart) parser will run over the folder and determine where what is placed.
    A ps1 file will help with the specific template for new content (auto generated in the complex type folder), it could be
    however that after saving the system will "type" it as something differently e.g. if i base it on "post with title" and
    leave off the title it will be classified as "post without a title".
</p>
<h3>Classification Folder: Taxonomy (which links a type to a group of terms)</h3>
<p>
    While the singular contents above already define a taxonomy. Under taxonomy we can make relations of types which we will can give
    a GUID or a name. E.g. if there are posts without a title and posts with a title we can either make this a complex type with
    a variable title which may be empty OR we make it a taxonomy where both types derive from the taxonomy term post and have child
    terms "post without title" and "post with title". The latter are types. The "post" is only a taxonomy term.
    Or e.g. if we have NL as main language we can have NL_nl and NL_be as as child taxonomy terms, which are all of the type
    language (or if we decide later, of different types), depending if we regard them as different types they will be placed
    in different folders.
</p>
<h3>Folder: Index</h3>
<p>
    This will contain indexes to allow for fast searching based on content or type or taxonomy.
</p>
<h3>Overall</h3>
<ul>
    <li>Every GUID should be unique over all items, this allows to build a flattened singular list.</li>
</ul>
<hr />
<ul>
    <li>Using: <a href="https://code.visualstudio.com/">Visual Studio Code</a></li>
    <li>Contact: <a href="https://github.com/projectje/projectje.github.io/issues">Contact</a></li>
</ul>
</body>
</html>